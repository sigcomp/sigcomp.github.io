<h2 id="problem-breakdown">Problem Breakdown</h2>
<blockquote>
  <p>For every test case, print a single output line giving the length of the shortest pattern that explains the given input string.</p>
</blockquote>

<p>Essentially, the problem asks you to find the shortest pattern that repeats itself from the beggining of the string to the end of the string, and possibly, the pattern is cut off on its final iteration. Take, for instance, the following string:</p>

<p><code class="highlighter-rouge">abbcabbcabbabbcabb</code></p>

<p>For this string, the longest “repeated” pattern is <code class="highlighter-rouge">abbcabbcabb</code> since it is followed by <code class="highlighter-rouge">abbcabb</code>, which follows the beginning of the pattern, but is cut off (hence the quotes around repeated). The length of the pattern is 11, and so that would be the answer in this case.</p>

<p>As another example, consider the following string:</p>

<p><code class="highlighter-rouge">I Repeat Myself I Repeat Myself I Repeat</code></p>

<p>The pattern in this case is <code class="highlighter-rouge">I Repeat Myself </code>, which is repeated twice and only partially completed during its last iteration.</p>

<h2 id="solution-explanation">Solution Explanation</h2>
<p>The problem can be solved in linear time (i.e. increasing the size of the string to find a pattern in will increase the run time by a constant factor) by using the following method. Make two variables to store indeces and a variable to store the candidate pattern (this will store our current best guess for the pattern). Then proceed as visualized below:</p>

<p><img src="/assets/solution_img/i_repeat_myself/i_repeat_gif.gif" alt="graphical representation of boss battle" title="visual representation of algorithm" /></p>

<p>As search continues one character at a time through the string, it is checked whether or not the characters pointed to by both indeces match. If they do not, the candidate string is updated to the string up until the index of the right-most marker, and the other marker is set to zero. This process is repeated until all the characters of the string have been examined.</p>

<p>There is one important special case that must be checked for. If the character which differs happens to be the same character at the beginning of the candidate string, the candidate string should only be updated until <em>just before</em> the right-most marker. This is because it may be the beginning of the pattern, as is the case in the GIF above.</p>

<h2 id="source-code">Source Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># left index marker</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># right index marker</span>
    <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
            <span class="c"># special case: non-match is same as start of pattern</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">right</span><span class="p">]</span> <span class="c"># don't include non-match</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c"># counter-act moving forward</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># start matching pattern at beginning again</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># move left marker forward</span>
        <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># move right marker forward</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">))</span>
</code></pre></div></div>
